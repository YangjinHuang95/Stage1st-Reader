//
//  Stage1stLog.swift
//  Stage1st
//
//  Created by Zheng Li on 16/02/2017.
//  Copyright Â© 2017 Renaissance. All rights reserved.
//

import CocoaLumberjack
import CrashlyticsLogger
import os

var asynchronousLogging: Bool = false

enum LogCategory: CustomStringConvertible, OSLoggerIndexable {
    case `default`

    /// Record network request sended by default network manager.
    case network

    /// Record user input.
    case interaction

    /// Record
    case environment

    /// Record log generated by our extension on UIKit / Foundation class.
    case `extension`

    /// Record UI changes.
    case ui

    /// Record auth state information.
    case auth

    case cloudkit

    var description: String {
        switch self {
        case .default:
            return "default"
        case .network:
            return "network"
        case .interaction:
            return "interaction"
        case .environment:
            return "environment"
        case .extension:
            return "extension"
        case .ui:
            return "ui"
        case .auth:
            return "auth"
        case .cloudkit:
            return "cloudkit"
        }
    }

    var loggerIndex: String {
        return description
    }
}

enum LogSubsystem: CustomStringConvertible, OSLoggerIndexable {
    case `default`
    var description: String {
        switch self {
        case .default:
            return "stage1st.default"
        }
    }

    var loggerIndex: String {
        return description
    }
}

class S1LoggerTag: OSLoggerTag {
    let subsystem: LogSubsystem
    let category: LogCategory

    var rawSubsystem: OSLoggerIndexable & CustomStringConvertible { return subsystem }
    var rawCategory: OSLoggerIndexable & CustomStringConvertible { return category }

    init(subsystem: LogSubsystem, category: LogCategory) {
        self.subsystem = subsystem
        self.category = category
    }
}

extension OSLog {
    @available(iOS 10.0, *)
    convenience init(subsystem: LogSubsystem, category: LogCategory) {
        self.init(subsystem: subsystem.description, category: category.description)
    }
}

func S1LogDebug(
    _ message: @autoclosure () -> String,
    level: DDLogLevel = defaultDebugLevel,
    context: Int = 0,
    file: StaticString = #file,
    function: StaticString = #function,
    line: UInt = #line,
    category: LogCategory = .default,
    subsystem: LogSubsystem = .default,
    asynchronous async: Bool = asynchronousLogging,
    ddlog: DDLog = DDLog.sharedInstance
) {
    _DDLogMessage(
        message,
        level: level,
        flag: .debug,
        context: context,
        file: file,
        function: function,
        line: line,
        tag: S1LoggerTag(subsystem: subsystem, category: category),
        asynchronous: async,
        ddlog: ddlog
    )
}

func S1LogInfo(
    _ message: @autoclosure () -> String,
    level: DDLogLevel = defaultDebugLevel,
    context: Int = 0,
    file: StaticString = #file,
    function: StaticString = #function,
    line: UInt = #line,
    category: LogCategory = .default,
    subsystem: LogSubsystem = .default,
    asynchronous async: Bool = asynchronousLogging,
    ddlog: DDLog = DDLog.sharedInstance
) {
    _DDLogMessage(
        message,
        level: level,
        flag: .info,
        context: context,
        file: file,
        function: function,
        line: line,
        tag: S1LoggerTag(subsystem: subsystem, category: category),
        asynchronous: async,
        ddlog: ddlog
    )
}

func S1LogWarn(
    _ message: @autoclosure () -> String,
    level: DDLogLevel = defaultDebugLevel,
    context: Int = 0,
    file: StaticString = #file,
    function: StaticString = #function,
    line: UInt = #line,
    category: LogCategory = .default,
    subsystem: LogSubsystem = .default,
    asynchronous async: Bool = asynchronousLogging,
    ddlog: DDLog = DDLog.sharedInstance
) {
    _DDLogMessage(
        message,
        level: level,
        flag: .warning,
        context: context,
        file: file,
        function: function,
        line: line,
        tag: S1LoggerTag(subsystem: subsystem, category: category),
        asynchronous: async,
        ddlog: ddlog
    )
}

func S1LogVerbose(
    _ message: @autoclosure () -> String,
    level: DDLogLevel = defaultDebugLevel,
    context: Int = 0,
    file: StaticString = #file,
    function: StaticString = #function,
    line: UInt = #line,
    category: LogCategory = .default,
    subsystem: LogSubsystem = .default,
    asynchronous async: Bool = asynchronousLogging,
    ddlog: DDLog = DDLog.sharedInstance
) {
    _DDLogMessage(
        message,
        level: level,
        flag: .verbose,
        context: context,
        file: file,
        function: function,
        line: line,
        tag: S1LoggerTag(subsystem: subsystem, category: category),
        asynchronous: async,
        ddlog: ddlog
    )
}

func S1LogError(
    _ message: @autoclosure () -> String,
    level: DDLogLevel = defaultDebugLevel,
    context: Int = 0,
    file: StaticString = #file,
    function: StaticString = #function,
    line: UInt = #line,
    category: LogCategory = .default,
    subsystem: LogSubsystem = .default,
    asynchronous async: Bool = false,
    ddlog: DDLog = DDLog.sharedInstance
) {
    _DDLogMessage(
        message,
        level: level,
        flag: .error,
        context: context,
        file: file,
        function: function,
        line: line,
        tag: S1LoggerTag(subsystem: subsystem, category: category),
        asynchronous: async,
        ddlog: ddlog
    )
}

public func DDLogTracking(
    _ message: @autoclosure () -> String,
    level: DDLogLevel = defaultDebugLevel,
    file: StaticString = #file,
    function: StaticString = #function,
    line: UInt = #line,
    tag: Any? = nil,
    asynchronous async: Bool = false,
    ddlog: DDLog = DDLog.sharedInstance
) {
    _DDLogMessage(
        message,
        level: level,
        flag: .error,
        context: 1024,
        file: file,
        function: function,
        line: line,
        tag: tag,
        asynchronous: async,
        ddlog: ddlog
    )
}
